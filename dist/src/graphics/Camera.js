import{CAMERA as t}from"../constants.js";export class Camera{constructor(i,o={width:1920,height:1080}){this.svg=i,this.viewBox=o,this.position={x:0,y:0},this.target={x:0,y:0},this.zoom=1,this.targetZoom=1,this.smoothing=t.FOLLOW_LERP,this.zoomSmoothness=t.ZOOM_SMOOTHNESS,this.minZoom=t.MIN_ZOOM,this.maxZoom=t.MAX_ZOOM,this.bounds={minX:-1e3,maxX:3e3,minY:-1e3,maxY:2e3},this.updateViewBox()}get x(){return this.position.x}get y(){return this.position.y}follow(t,i){this.target.x=t,this.target.y=i}setZoom(t){this.targetZoom=Math.max(this.minZoom,Math.min(this.maxZoom,t))}setZoomImmediate(t){this.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,t)),this.targetZoom=this.zoom,this.updateViewBox()}zoomIn(i=t.ZOOM_FACTOR){this.setZoom(this.targetZoom*i)}zoomOut(i=t.ZOOM_FACTOR){this.setZoom(this.targetZoom/i)}update(){const t=this.target.x-this.position.x,i=this.target.y-this.position.y;this.position.x+=t*this.smoothing,this.position.y+=i*this.smoothing,this.position.x=Math.max(this.bounds.minX,Math.min(this.bounds.maxX,this.position.x)),this.position.y=Math.max(this.bounds.minY,Math.min(this.bounds.maxY,this.position.y));const o=this.targetZoom-this.zoom;this.zoom+=o*this.zoomSmoothness,this.updateViewBox()}updateViewBox(){const t=this.viewBox.width/this.zoom/2,i=this.viewBox.height/this.zoom/2,o=this.position.x-t,s=this.position.y-i,h=this.viewBox.width/this.zoom,m=this.viewBox.height/this.zoom;this.svg.setAttribute("viewBox",`${o} ${s} ${h} ${m}`)}worldToScreen(t,i){const o=this.viewBox.width/this.zoom/2,s=this.viewBox.height/this.zoom/2;return{x:(t-(this.position.x-o))*this.zoom,y:(i-(this.position.y-s))*this.zoom}}screenToWorld(t,i){const o=this.viewBox.width/this.zoom/2,s=this.viewBox.height/this.zoom/2;return{x:t/this.zoom+(this.position.x-o),y:i/this.zoom+(this.position.y-s)}}getVisibleBounds(){const t=this.viewBox.width/this.zoom/2,i=this.viewBox.height/this.zoom/2;return{left:this.position.x-t,right:this.position.x+t,top:this.position.y-i,bottom:this.position.y+i}}isVisible(t,i,o=0){const s=this.getVisibleBounds();return t+o>s.left&&t-o<s.right&&i+o>s.top&&i-o<s.bottom}setBounds(t,i,o,s){this.bounds={minX:t,maxX:i,minY:o,maxY:s}}setSmoothness(i=t.FOLLOW_LERP){this.smoothing=Math.max(t.FOLLOW_THRESHOLD,Math.min(1,i))}setZoomLimits(i=t.MIN_ZOOM,o=t.MAX_ZOOM){this.minZoom=i,this.maxZoom=o,this.targetZoom=Math.max(i,Math.min(o,this.targetZoom))}centerOn(t,i){this.position.x=t,this.position.y=i,this.target.x=t,this.target.y=i,this.updateViewBox()}shake(i=t.SHAKE_INTENSITY,o=t.SHAKE_DURATION){const s=this.smoothing;this.smoothing=1;const h=Date.now(),shakeLoop=()=>{const m=Date.now()-h;if(m<o){const s=i*(1-m/o);this.position.x+=(Math.random()-t.VIEWPORT_CENTER)*s,this.position.y+=(Math.random()-t.VIEWPORT_CENTER)*s,requestAnimationFrame(shakeLoop)}else this.smoothing=s};requestAnimationFrame(shakeLoop)}}