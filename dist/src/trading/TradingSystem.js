import{TRADING as e}from"../constants.js";export class TradingSystem{constructor(){this.items=new Map,this.playerInventory=new Map,this.stationInventories=new Map,this.priceHistory=new Map,this.playerCredits=1e3,this.initializeItems(),this.initializeStationInventories()}initializeItems(){[{id:"ore-iron",name:"Iron Ore",category:"raw-materials",basePrice:15,volatility:.2,description:"Basic metallic ore used in construction"},{id:"ore-copper",name:"Copper Ore",category:"raw-materials",basePrice:25,volatility:.3,description:"Conductive metal essential for electronics"},{id:"fuel-hydrogen",name:"Hydrogen Fuel",category:"fuel",basePrice:45,volatility:.4,description:"Clean-burning spacecraft fuel"},{id:"food-rations",name:"Food Rations",category:"consumables",basePrice:30,volatility:.1,description:"Preserved food for long space journeys"},{id:"tech-processors",name:"Quantum Processors",category:"technology",basePrice:150,volatility:.5,description:"Advanced computing components"},{id:"med-supplies",name:"Medical Supplies",category:"medical",basePrice:80,volatility:.2,description:"Essential medical equipment and pharmaceuticals"}].forEach(e=>{this.items.set(e.id,{...e,currentPrice:e.basePrice})})}initializeStationInventories(){this.stationInventories.set("tradingStation",{inventory:new Map([["ore-iron",{quantity:150,buyPrice:12,sellPrice:18}],["ore-copper",{quantity:80,buyPrice:22,sellPrice:28}],["fuel-hydrogen",{quantity:50,buyPrice:40,sellPrice:50}],["food-rations",{quantity:200,buyPrice:25,sellPrice:35}]]),credits:1e4,demandMultipliers:{"ore-iron":.9,"ore-copper":1.1,"fuel-hydrogen":1.2,"food-rations":.8}})}getItem(e){return this.items.get(e)}getPlayerInventory(){return Array.from(this.playerInventory.entries()).map(([e,t])=>({item:this.getItem(e),quantity:t}))}getStationInventory(e){const t=this.stationInventories.get(e);return t?{credits:t.credits,items:Array.from(t.inventory.entries()).map(([e,t])=>({item:this.getItem(e),quantity:t.quantity,buyPrice:t.buyPrice,sellPrice:t.sellPrice}))}:null}canBuyFromStation(e,t,r){const i=this.stationInventories.get(e);if(!i)return{success:!1,error:"Station not found"};const n=i.inventory.get(t);if(!n)return{success:!1,error:"Item not available"};if(n.quantity<r)return{success:!1,error:"Insufficient stock"};return{success:!0,cost:n.sellPrice*r}}canSellToStation(e,t,r,i){const n=this.stationInventories.get(e);if(!n)return{success:!1,error:"Station not found"};const s=n.inventory.get(t);if(!s)return{success:!1,error:"Station does not buy this item"};if((this.playerInventory.get(t)||0)<r)return{success:!1,error:"Insufficient inventory"};const o=s.buyPrice*r;return n.credits<o?{success:!1,error:"Station has insufficient credits"}:{success:!0,value:o}}buyFromStation(e,t,r,i){const n=this.canBuyFromStation(e,t,r);if(!n.success)return n;if(i<n.cost)return{success:!1,error:"Insufficient credits"};const s=this.stationInventories.get(e),o=s.inventory.get(t);o.quantity-=r,s.credits+=n.cost;const a=this.playerInventory.get(t)||0;return this.playerInventory.set(t,a+r),this.updatePrices(e,t,"buy",r),{success:!0,cost:n.cost,newPlayerQuantity:a+r,newStationQuantity:o.quantity}}sellToStation(e,t,r){const i=this.canSellToStation(e,t,r,0);if(!i.success)return i;const n=this.stationInventories.get(e),s=n.inventory.get(t);s.quantity+=r,n.credits-=i.value;const o=this.playerInventory.get(t);return this.playerInventory.set(t,o-r),0===this.playerInventory.get(t)&&this.playerInventory.delete(t),this.updatePrices(e,t,"sell",r),{success:!0,value:i.value,newPlayerQuantity:Math.max(0,o-r),newStationQuantity:s.quantity}}updatePrices(t,r,i,n){if("string"!=typeof t||""===t.trim())throw new Error("Invalid stationId: must be a non-empty string");if("string"!=typeof r||""===r.trim())throw new Error("Invalid itemId: must be a non-empty string");if("string"!=typeof i||!["buy","sell"].includes(i))throw new Error('Invalid action: must be "buy" or "sell"');if("number"!=typeof n||!isFinite(n)||n<=0)throw new Error("Invalid quantity: must be a positive finite number");const s=this.stationInventories.get(t);if(!s)throw new Error(`Trading station '${t}' not found`);const o=s.inventory.get(r);if(!o)return;const a=n*e.PRICE_VARIANCE_LOW;"buy"===i?(o.sellPrice+=a,o.buyPrice+=a*e.PRICE_VARIANCE_HIGH):"sell"===i&&(o.sellPrice-=a,o.buyPrice-=a*e.PRICE_VARIANCE_HIGH);const c=this.getItem(r);o.sellPrice=Math.max(c.basePrice*e.PRICE_BOUNDS_MIN_SELL,o.sellPrice),o.buyPrice=Math.max(c.basePrice*e.PRICE_BOUNDS_MIN_BUY,o.buyPrice),o.sellPrice=Math.min(c.basePrice*e.PRICE_BOUNDS_MAX_SELL,o.sellPrice),o.buyPrice=Math.min(c.basePrice*e.PRICE_BOUNDS_MAX_BUY,o.buyPrice)}addPlayerItem(e,t){const r=this.playerInventory.get(e)||0;this.playerInventory.set(e,r+t)}getPlayerItemQuantity(e){return this.playerInventory.get(e)||0}getTotalInventoryValue(){let e=0;for(const[t,r]of this.playerInventory){const i=this.getItem(t);i&&(e+=i.basePrice*r)}return e}getPlayerItems(){return Array.from(this.playerInventory.entries()).map(([e,t])=>({id:e,quantity:t,item:this.getItem(e)}))}getPlayerCredits(){return this.playerCredits}setPlayerCredits(e){this.playerCredits=Math.max(0,e)}buyItem(e,t,r){const i=e.market[t];if(!i)return{success:!1,error:"Item not available"};const n=i.sellPrice*r;return this.playerCredits<n?{success:!1,error:"Insufficient credits"}:i.supply<r?{success:!1,error:"Insufficient stock"}:(this.playerCredits-=n,this.addPlayerItem(t,r),i.supply-=r,{success:!0,cost:n,newPlayerQuantity:this.getPlayerItemQuantity(t)})}sellItem(e,t,r){const i=e.market[t];if(!i)return{success:!1,error:"Station does not buy this item"};if(this.getPlayerItemQuantity(t)<r)return{success:!1,error:"Insufficient inventory"};const n=i.buyPrice*r;this.playerCredits+=n;const s=this.playerInventory.get(t);return this.playerInventory.set(t,s-r),0===this.playerInventory.get(t)&&this.playerInventory.delete(t),{success:!0,value:n,newPlayerQuantity:this.getPlayerItemQuantity(t)}}}