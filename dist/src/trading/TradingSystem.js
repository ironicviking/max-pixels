import{TRADING as e}from"../constants.js";export class TradingSystem{constructor(){this.items=new Map,this.playerInventory=new Map,this.stationInventories=new Map,this.priceHistory=new Map,this.playerCredits=1e3,this.initializeItems(),this.initializeStationInventories()}initializeItems(){[{id:"ore-iron",name:"Iron Ore",category:"raw-materials",basePrice:15,volatility:.2,description:"Basic metallic ore used in construction"},{id:"ore-copper",name:"Copper Ore",category:"raw-materials",basePrice:25,volatility:.3,description:"Conductive metal essential for electronics"},{id:"fuel-hydrogen",name:"Hydrogen Fuel",category:"fuel",basePrice:45,volatility:.4,description:"Clean-burning spacecraft fuel"},{id:"food-rations",name:"Food Rations",category:"consumables",basePrice:30,volatility:.1,description:"Preserved food for long space journeys"},{id:"tech-processors",name:"Quantum Processors",category:"technology",basePrice:150,volatility:.5,description:"Advanced computing components"},{id:"med-supplies",name:"Medical Supplies",category:"medical",basePrice:80,volatility:.2,description:"Essential medical equipment and pharmaceuticals"}].forEach(e=>{this.items.set(e.id,{...e,currentPrice:e.basePrice})})}initializeStationInventories(){this.stationInventories.set("tradingStation",{inventory:new Map([["ore-iron",{quantity:150,buyPrice:12,sellPrice:18}],["ore-copper",{quantity:80,buyPrice:22,sellPrice:28}],["fuel-hydrogen",{quantity:50,buyPrice:40,sellPrice:50}],["food-rations",{quantity:200,buyPrice:25,sellPrice:35}]]),credits:1e4,demandMultipliers:{"ore-iron":.9,"ore-copper":1.1,"fuel-hydrogen":1.2,"food-rations":.8}})}getItem(e){return this.items.get(e)}getPlayerInventory(){return Array.from(this.playerInventory.entries()).map(([e,t])=>({item:this.getItem(e),quantity:t}))}getStationInventory(e){const t=this.stationInventories.get(e);return t?{credits:t.credits,items:Array.from(t.inventory.entries()).map(([e,t])=>({item:this.getItem(e),quantity:t.quantity,buyPrice:t.buyPrice,sellPrice:t.sellPrice}))}:null}canBuyFromStation(e,t,r){const i=this.stationInventories.get(e);if(!i)return{success:!1,error:"Station not found"};const s=i.inventory.get(t);if(!s)return{success:!1,error:"Item not available"};if(s.quantity<r)return{success:!1,error:"Insufficient stock"};return{success:!0,cost:s.sellPrice*r}}canSellToStation(e,t,r,i){const s=this.stationInventories.get(e);if(!s)return{success:!1,error:"Station not found"};const n=s.inventory.get(t);if(!n)return{success:!1,error:"Station does not buy this item"};if((this.playerInventory.get(t)||0)<r)return{success:!1,error:"Insufficient inventory"};const o=n.buyPrice*r;return s.credits<o?{success:!1,error:"Station has insufficient credits"}:{success:!0,value:o}}buyFromStation(e,t,r,i){const s=this.canBuyFromStation(e,t,r);if(!s.success)return s;if(i<s.cost)return{success:!1,error:"Insufficient credits"};const n=this.stationInventories.get(e),o=n.inventory.get(t);o.quantity-=r,n.credits+=s.cost;const a=this.playerInventory.get(t)||0;return this.playerInventory.set(t,a+r),this.updatePrices(t,"buy",r),{success:!0,cost:s.cost,newPlayerQuantity:a+r,newStationQuantity:o.quantity}}sellToStation(e,t,r){const i=this.canSellToStation(e,t,r,0);if(!i.success)return i;const s=this.stationInventories.get(e),n=s.inventory.get(t);n.quantity+=r,s.credits-=i.value;const o=this.playerInventory.get(t);return this.playerInventory.set(t,o-r),0===this.playerInventory.get(t)&&this.playerInventory.delete(t),this.updatePrices(t,"sell",r),{success:!0,value:i.value,newPlayerQuantity:Math.max(0,o-r),newStationQuantity:n.quantity}}updatePrices(t,r,i){const s=this.stationInventories.get("tradingStation").inventory.get(t);if(!s)return;const n=i*e.PRICE_VARIANCE_LOW;"buy"===r?(s.sellPrice+=n,s.buyPrice+=n*e.PRICE_VARIANCE_HIGH):"sell"===r&&(s.sellPrice-=n,s.buyPrice-=n*e.PRICE_VARIANCE_HIGH);const o=this.getItem(t);s.sellPrice=Math.max(o.basePrice*e.PRICE_BOUNDS_MIN_SELL,s.sellPrice),s.buyPrice=Math.max(o.basePrice*e.PRICE_BOUNDS_MIN_BUY,s.buyPrice),s.sellPrice=Math.min(o.basePrice*e.PRICE_BOUNDS_MAX_SELL,s.sellPrice),s.buyPrice=Math.min(o.basePrice*e.PRICE_BOUNDS_MAX_BUY,s.buyPrice)}addPlayerItem(e,t){const r=this.playerInventory.get(e)||0;this.playerInventory.set(e,r+t)}getPlayerItemQuantity(e){return this.playerInventory.get(e)||0}getTotalInventoryValue(){let e=0;for(const[t,r]of this.playerInventory){const i=this.getItem(t);i&&(e+=i.basePrice*r)}return e}getPlayerItems(){return Array.from(this.playerInventory.entries()).map(([e,t])=>({id:e,quantity:t,item:this.getItem(e)}))}getPlayerCredits(){return this.playerCredits}setPlayerCredits(e){this.playerCredits=Math.max(0,e)}buyItem(e,t,r){const i=e.market[t];if(!i)return{success:!1,error:"Item not available"};const s=i.sellPrice*r;return this.playerCredits<s?{success:!1,error:"Insufficient credits"}:i.supply<r?{success:!1,error:"Insufficient stock"}:(this.playerCredits-=s,this.addPlayerItem(t,r),i.supply-=r,{success:!0,cost:s,newPlayerQuantity:this.getPlayerItemQuantity(t)})}sellItem(e,t,r){const i=e.market[t];if(!i)return{success:!1,error:"Station does not buy this item"};if(this.getPlayerItemQuantity(t)<r)return{success:!1,error:"Insufficient inventory"};const s=i.buyPrice*r;this.playerCredits+=s;const n=this.playerInventory.get(t);return this.playerInventory.set(t,n-r),0===this.playerInventory.get(t)&&this.playerInventory.delete(t),{success:!0,value:s,newPlayerQuantity:this.getPlayerItemQuantity(t)}}}